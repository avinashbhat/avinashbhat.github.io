---
layout: post
title: The SZZ Algorithm
description: Can you repair compilation errors with Deep Learning?
summary: "Interesting research on program repair using Abstract Syntax Trees."
date: 2020-12-18T00:00:00.000Z
category: blog
comments: true
tags:

published: true
---

> Jacek Śliwerski, Thomas Zimmermann, and Andreas Zeller. 2005. When do changes induce fixes? In Proceedings of the 2005 international workshop on Mining software repositories (MSR '05). Association for Computing Machinery, New York, NY, USA, 1–5. DOI:https://doi.org/10.1145/1083142.1083147

<br>

What your tech lead says not to commit on a Friday, he is backed by research and not just lazy to review your code.
<br><br>
<div style="text-align:center;">
<img style="width:50%" alt="Funny Paper Title." src="{{site.baseurl}}/assets/images/2020-12-18-01.png"/>
</div>
<div style="width:484px height:319px; font-size:80%; text-align:center;">
	Title definitely serves as a tl;dr.
</div>
<br>

## [Abstract](#abstract)
Sometimes the code changes that developers make further induce bugs which need fixes. This paper provides a mechanism to locate such code changes and further inspects the patterns between such fix-inducing changes and the size of the commit and the day when the commit was made.

## [Introduction](#introduction)
Software development never really goes in a straight line. There is always a possibility that a commit leads to a bug. SZZ is one such algorithm that tries to detect those changes that caused a bug. The algorithm can be intuitively described as follows. 
1. Start with the bug report, that indicates a fixed problem. 
2. Get the exact code lines were changed in that particular commit, which were used to fix a problem.
3. Next we can find the earlier changes that were made, in a previous commit at that location. This earlier change is denoted as a *fix-inducing change*.

This is definitely of interest, because one does not really want to induce a bug in the code. If it is possible to identify a commit that can potentially cause a problem, well I'd take it any day. Authors have also outlined few other reasons why identifying such a commit is desirable. 
- **To identify which properties of a commit can cause a problem.** There can be other correlations like the day or time a commit was made, changes made by a certain developer or a group of developers, the possibilities are endless. This is pretty interesting, giving rise to avenues of mining developer behavior.
- **To identify the possibility of errors in a code base.** We can identify on an average how likely a change is fix-inducing.
- **To filter out problematic changes.** Any future analysis, need not take the fix-inducing change into account.
- **To improve guidance along related changes.** Usually, the fix-inducing commit is a part of set of commits that are a part of a feature. While describing the feature, the fix-inducing commits need not be included.

## [Data Collection](#dc)
The data required to analyse the commits comes from the version control systems like CVS and bug tracking systems like Bugzilla. 

A code *change* $$\delta$$ transforms a revision $$r_{1}$$ to a revision $$r_{2}$$ by inserting, deleting or changing lines. A group of such changes form a *transaction* $$t$$ as long as they are for the same purpose. Since CVS records file level changes, a *sliding time window* approach [^1] is used to group the transactions.

To make the transaction groups more meaningful and precise, it is further linked to a bug report at Bugzilla. A Bugzilla report contains couple of metadata regarding the bug. There is a *reporter* field denoting the person who raised the bug, along with a *short description* and *summary* of the bug. There are additional *comments* and *attachments* fields which contain community discussions post which bug is *assigned* to a developer. A bug lifecycle contains one of the following *status* - **UNCONFIRMED**, **NEW**, **ASSIGNED**, **RESOLVED**, or **CLOSED** and one of the following *resolution* - **FIXED**, **DUPLICATE**, or **INVALID**.

Usually developers associate a commit with a *bug report number* in the commit message when they fix a bug. Using this relation, a database of the bugs and the associated commits is created [^2].
<br><br>
<div style="text-align:center;">
<img style="width:50%" alt="Associating a commit with a bug." src="{{site.baseurl}}/assets/images/2020-12-18-02.png"/>
</div>
<div style="width:484px height:319px; font-size:80%; text-align:center;">
Linking bugs to commits.
</div>
<br>

A link $$(t, b)$$ between a transaction $$t$$ and a bug $$b$$ has *syntactic level* property and a *semantic level* property.

### [Syntactic Analysis](#syn)
Syntactic analysis uses the commit message to link the commit to the bug. A commit message is first parsed into tokens. A token can be one of the following.
- *Bug Number* - if it matches the regex.
    - `bug[# \t]*[0-9]+`
    - `pr[# \t]*[0-9]+`
    - `show\_bug\.cgi\?id=[0-9]+`
    - `\[[0-9]+\]`
- *Plain Number* - which is a string of digits `[0-9]+`
- *Keyword* - if it matches `fix(e[ds])?|bugs?|defects?|patch`
- *Word* - which is a string of alphanumeric characters

Syntactic confidence is a number between 0 and 2. It is initialised to 0, and incremented if the following rules are satisfied.
1. The number is a *bug number*.
2. Log message contains a *keyword* OR contains *plain number* or *bug number*.

For example, 
- `Fixed bug 53784: .class file missing from jar file export` This message contains a *bug number* `53784` and a *keyword* `Fixed` which makes the confidence as 2.
- `52264, 51529` Confidence is 1 as they only have *bug numbers*.
- `Updated copyrights to 2004` Since there is no valid token, the syntactic confidence is 0.

### [Semantic Analysis](#sem)
Semantic analysis leverages the metadata captured in the bug report. The semantic confidence is initialised to 0 and incremented when the following rules are satisfied.
1. If the bug $$b$$ has been resolved as **FIXED** atleast once.
2. If the description of $$b$$ is captured in commit message of transaction $$t$$.
3. If the person *assigned* to the bug $$b$$ has committed the transaction $$t$$.
4. One or more files committed in transaction $$t$$ are mentioned in bug $$b$$.


## [Thoughts](#thoughts)
The paper discusses a 

## [Interesting References for Better Understanding](#references)
[^1]: [Preprocessing CVS Data for Fine-Grained Analysis](http://2004.msrconf.org/papers/Zimmermann.pdf)
[^2]: [Hipikat: Recommending Pertinent Software Development Artifacts](http://www.cs.kent.edu/~jmaletic/cs63902/Papers/Murphy03.pdf)